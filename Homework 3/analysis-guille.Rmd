---
title: "Homework 3"
output:
  html_document:
    df_print: paged
---

<!-- Note: this file is a copy of "analysis-nacho" -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=TRUE}
library(xlsx)
library(ggplot2)
library(forecast)
library(tseries)
library(MuMIn)
library(gridExtra)
library(astsa)
library(zoo)
library(car)
```


```{r}
housing <- read.xlsx("data_g5.xlsx", sheetName = "6.19 r")
head(housing)
```


## Question 1
### Plot the series and briefly comment on the characteristics you observe (stationarity, trend, seasonality...).

```{r}
housing_ts <- ts(housing[,2], frequency=12, start=c(1990,1))
autoplot(housing_ts)
#Seasonality in depth
ggmonthplot(housing_ts) #Monthly
ggseasonplot(housing_ts, continuous = TRUE) #Yearly
```

* Trend: There is a trend over time and we can see different patterns. There is a changing trend that has a positive slope between 1991 and 1993, a negative slope between 1993 and 2003, and a positive slope from 2003 and onwards. 

* Seasonality: It seems that there is no seasonality, as there is not a regularly repeating pattern related.

* Cyclical components: There is no evidence of any cyclic behaviour in the data.

Taking these observations into account, we can state that we are working with a non-stationary time Series. Even if the time series shows no seasonal or cyclical components, the presence of trends makes it non-stationary.


## Question 2.
### Obtain a plot of the decomposition of the series, using stl(). Use an additive decomposition
or a multiplicative one, depending on your data.


```{r}
#Additive decomposition
stl1.housing <- stl(housing_ts,  s.window="periodic", robust=TRUE)
stl2.housing <- stl(housing_ts,  s.window=5, robust=TRUE)
stl3.housing <- stl(housing_ts,  s.window=15, robust=TRUE)

#Compare seasonal components tunning parameter s.window
season1=autoplot(stl1.housing$time.series[,1])
season2=autoplot(stl2.housing$time.series[,1])
season3=autoplot(stl3.housing$time.series[,1]) 
grid.arrange(season1, season2, season3, ncol= 1)
```

We have used an additive decomposition, since there are no changes in seasonal components. We can see that using the first seasonal window (s.window = periodic), the seasonal components are small, centered around zero and more or less constant. Since the seasonality plots obtained before showed no influence of seasonal components, we will choose this seasonal window.

```{r}
stl1.housing <- stl(housing_ts, s.window="periodic", robust=TRUE)
stl2.housing <- stl(housing_ts, t.window = 5, s.window="periodic", robust=TRUE)
stl3.housing <- stl(housing_ts, t.window = 15, s.window="periodic", robust=TRUE)

#Compare trends
trend1 = autoplot(stl1.housing$time.series[,2])
trend2=autoplot(stl2.housing$time.series[,2]) #more wiggly trend
trend3=autoplot(stl3.housing$time.series[,2])
grid.arrange(trend1, trend2, trend3, ncol= 1)
```

Keeping a periodic window for the seasonal components (assuming they are equal across the years), we can see that using the second trend window (t.window = 5), produces the trend that better captures the structure of the data. Thus, we will choose it.


```{r}
#Final decomposition
stl.housing <- stl(housing_ts, t.window=5, s.window="periodic", robust=TRUE)
#stl.housing #seasonal, trend, remainder
plot(stl.housing)

# seasonal factors
seasonal.factors<-stl.housing$time.series[,1]
min(seasonal.factors)
max(seasonal.factors)

# remainder
housing.remainder<-stl.housing$time.series[,3]
min(housing.remainder)
max(housing.remainder)
mean(housing.remainder)

#plotting the original series and the seasonal adjusted one, to see the trend
pl1=autoplot(housing_ts)
pl2=autoplot(seasadj(stl.housing))
grid.arrange(pl1, pl2, ncol= 1)
```


Watching the decomposition plot resulting from the selected windows, we can see that the seasonal components have low constant values that are centered around zero ([-0.192,0.124]). The structure of the data is captured well by the trend component and the seasonal adjusted series is just like the original one. The remainder values are somewhat big ([-1.34,1.84]), but have zero mean (-0.0153).


### Use the function forecast() to forecast future values. 
```{r}
#Training and testing data split
housing.train=window(housing_ts, end=2004-0.001) #~0.8
housing.test=window(housing_ts,start=2004) #~0.2
#The slope at the transition between testing and training datasets influences how easy is to predict the future values. The year at which we divide the time series determines which method has the lowest RMSE.

#forecasting with stl(): different methods: naive, ets, arima, rwdrift
stl.housing <- stl(housing.train, t.window=5, s.window="periodic", robust=TRUE)

#naive
fcst=forecast(stl.housing, method="naive", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean - housing.test)^2, na.rm=TRUE))

#ets
fcst=forecast(stl.housing, method="ets", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean-housing.test)^2, na.rm=TRUE))

#arima
fcst=forecast(stl.housing, method="arima", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean-housing.test)^2, na.rm=TRUE))

#rwdrift
fcst=forecast(stl.housing, method="rwdrift", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean-housing.test)^2, na.rm=TRUE)) #Lowest RMSE
```
Using stl() to forecast, we can see that using the random walk with drift method to predict future values results in the lowest RMSE.

### Does the remainder look like a white noise to you? Answer to this point just visually or plot the ACF and PACF of the remainder part.

```{r}
#Remainder
stl.housing <- stl(housing_ts, t.window=5, s.window="periodic", robust=TRUE)
autoplot(stl.housing)
housing.remainder<-stl.housing$time.series[,3]
autoplot(housing.remainder) 

#ACF and PACF
acf2(housing.remainder)

#Gaussian noise
gn = rnorm(length(housing.remainder),mean=mean(housing.remainder[-1]),sd=sd(housing.remainder[-1]))
gn=ts(gn)

#Comparison
plot1=autoplot(housing.remainder)
plot2=autoplot(gn)
grid.arrange(plot1, plot2, ncol= 1)

plot3=ggAcf(zoo::coredata(housing.remainder))
plot4=ggAcf(gn) #comparing with gaussian noise
grid.arrange(plot3,plot4,ncol=1)
```

The remainder does not look like gaussian noise, since it does not have a constant variance. 

<!-- Note: this file is a continuation of "analysis-nacho" -->

## Question 3
### Fit an ARIMA model to your time series. Some steps to follow

  a) *Decide on whether to work with your original variable or with the log transform one (use plot and tsdisplay of both variables, the transformed one and the original one). Remember that logarithmic transformation is useful to stabilize the variance. If both plots look almost the same to you, just use the original data.*
  
```{r}
log.housing_ts <- log(housing_ts)
tsdisplay(log.housing_ts); 
tsdisplay(housing_ts)
```
  
There is barely any difference, so we will use the original data (housing_ts)

  b) *Are you going to consider a seasonal component? If the answer is yes, identify s. You can use the periodogram (function tsdisplay with parameter “plot.type=spectrum”), ACF (with significant correlations on lag s and its multiples), seasonplot() and monthplot(). For montlhy data, s = 12; for quarterly data s = 4. Declare this frequency when you define your time-series in R, regardless of including or not a seasonal term in your model. This will permit you to use the functions seasonplot (package forecast) or monthplot (built-in function).*
  
  As previously stated, we can see that there is no seasonality, and this can be seen pretty easily by using the function `ggseasonplot` with the chosen data. We can also plot the Seasonal Decomposition to see that the values of the "season" are really low, between -0.2 and 0.1:
  
```{r}
#We already created the Ts with s = 12:
#housing_ts <- ts(housing[,2], frequency=12, start=c(1990,1))

#We re-print the season plot 
ggseasonplot(housing_ts)

#Final decomposition
stl.housing <- stl(housing_ts, t.window=5, s.window="periodic", robust=TRUE)
#stl.housing #seasonal, trend, remainder
plot(stl.housing)
```
  

  c) *Decide on the values of d and D to make your series stationary. D values are not usually greater than 1. You can use the standard deviation procedure and stationary tests (adf.test, kpss.test). Also, functions like ndiffs and nsdiffs may be useful. Don’t be surprised if that group of tools give you contradictory results. Just, make decision to keep going. Plots of the ACF and PACF also help. If you can draw a pattern out of the ACF and PACF function, then stop differencing and start modelling. If that pattern doesn’t work, then consider rethinking the part where you took differences.*
  
  We start testing to get the best "D" for our ARIMA model.
  (Nacho: I think we are testing "d")
  
```{r}
#Final decomposition
stl.housing <- stl(housing_ts, t.window=5, s.window="periodic", robust=TRUE)

#We begin by testing the different D values in a stl to see the results:
d.ts = ts(diff(housing_ts), frequency = 12)
d.test = stl(d.ts, t.window=5, s.window = "periodic", robust=TRUE)

plot(stl.housing)
plot(d.test)

#A formal ADF test does not reject the null hypothesis
adf.test(housing_ts, alternative = c("stationary"))
  #the lower it gets is p-value = 0.4142 w/ lag = 5

#However with the differenced time series we can reject the hypothesis of non-stationarity
adf.test(d.ts, alternative = c("stationary"))

#We can reject the null hypothesis that it's stationary (p=0.01) at 5% level
kpss.test(housing_ts)
```

  So it may be a good idea to consider differencing the data, given that the default data structure chosen may be shomewhat stationary. So here on out we will be uing the `dts` time series  

  d) *Identify values for p and q for the regular part and P and Q for the seasonal part. Start with low values and then increase them, one at a time. Fit different models and compare them using AICc and checking the residuals. Check also the correlation between the coefficients of the model.*

Let's go nuts and try all models!
```{r}
#Final decomposition
stl.housing <- stl(housing_ts, t.window=5, s.window="periodic", robust=TRUE)

models.1 = c(#d and D
           AICc(Arima(housing_ts,order=c(0,0,0))),
           AICc(Arima(housing_ts,order=c(0,1,0))), #Best: d=1, D=0
           AICc(Arima(housing_ts,order=c(0,0,0))),
           AICc(Arima(housing_ts,order=c(0,1,0)))
           )
models.1
min(models.1)

models.2 = c(#p and q
           AICc(Arima(housing_ts,order=c(0,1,0))),
           AICc(Arima(housing_ts,order=c(0,1,1))),
           AICc(Arima(housing_ts,order=c(0,1,2))),
           AICc(Arima(housing_ts,order=c(0,1,3))),
           AICc(Arima(housing_ts,order=c(0,1,4))),
           AICc(Arima(housing_ts,order=c(0,1,5))),
           AICc(Arima(housing_ts,order=c(0,1,6))),
           AICc(Arima(housing_ts,order=c(0,1,7))),
           AICc(Arima(housing_ts,order=c(0,1,8))),
           AICc(Arima(housing_ts,order=c(0,1,9))),
           AICc(Arima(housing_ts,order=c(0,1,10))),
           AICc(Arima(housing_ts,order=c(0,1,11))),
           AICc(Arima(housing_ts,order=c(0,1,12))),
           
           AICc(Arima(housing_ts,order=c(1,1,0))),
           AICc(Arima(housing_ts,order=c(1,1,1))),
           AICc(Arima(housing_ts,order=c(1,1,2))),
           AICc(Arima(housing_ts,order=c(1,1,3))),
           AICc(Arima(housing_ts,order=c(1,1,4))),
           AICc(Arima(housing_ts,order=c(1,1,5))),
           AICc(Arima(housing_ts,order=c(1,1,6))),
           AICc(Arima(housing_ts,order=c(1,1,7))),
           AICc(Arima(housing_ts,order=c(1,1,8))),
           AICc(Arima(housing_ts,order=c(1,1,9))),
           AICc(Arima(housing_ts,order=c(1,1,10))),
           AICc(Arima(housing_ts,order=c(1,1,11))),
           AICc(Arima(housing_ts,order=c(1,1,12))),
           
           AICc(Arima(housing_ts,order=c(2,1,0))),
           AICc(Arima(housing_ts,order=c(2,1,1))),
           AICc(Arima(housing_ts,order=c(2,1,2))),
           AICc(Arima(housing_ts,order=c(2,1,3))),
           AICc(Arima(housing_ts,order=c(2,1,4))),
           AICc(Arima(housing_ts,order=c(2,1,5))),
           AICc(Arima(housing_ts,order=c(2,1,6))),
           AICc(Arima(housing_ts,order=c(2,1,7))),
           AICc(Arima(housing_ts,order=c(2,1,8))),
           AICc(Arima(housing_ts,order=c(2,1,9))),
           AICc(Arima(housing_ts,order=c(2,1,10))),
           AICc(Arima(housing_ts,order=c(2,1,11))),
           AICc(Arima(housing_ts,order=c(2,1,12))),
           
           AICc(Arima(housing_ts,order=c(3,1,0))),
           AICc(Arima(housing_ts,order=c(3,1,1))),
           AICc(Arima(housing_ts,order=c(3,1,2))),
           AICc(Arima(housing_ts,order=c(3,1,3))), #Best: p=q=3
           AICc(Arima(housing_ts,order=c(3,1,4))),
           AICc(Arima(housing_ts,order=c(3,1,5))),
           AICc(Arima(housing_ts,order=c(3,1,6))),
           AICc(Arima(housing_ts,order=c(3,1,7))),
           AICc(Arima(housing_ts,order=c(3,1,8))),
           AICc(Arima(housing_ts,order=c(3,1,9))),
           AICc(Arima(housing_ts,order=c(3,1,10))),
           AICc(Arima(housing_ts,order=c(3,1,11))),
           AICc(Arima(housing_ts,order=c(3,1,12))),
           
           AICc(Arima(housing_ts,order=c(4,1,0))),
           AICc(Arima(housing_ts,order=c(4,1,1))),
           AICc(Arima(housing_ts,order=c(4,1,2))),
           AICc(Arima(housing_ts,order=c(4,1,3))),
           AICc(Arima(housing_ts,order=c(4,1,4))),
           AICc(Arima(housing_ts,order=c(4,1,5))),
           AICc(Arima(housing_ts,order=c(4,1,6))),
           AICc(Arima(housing_ts,order=c(4,1,7))),
           AICc(Arima(housing_ts,order=c(4,1,8))),
           AICc(Arima(housing_ts,order=c(4,1,9))),
           AICc(Arima(housing_ts,order=c(4,1,10))),
           AICc(Arima(housing_ts,order=c(4,1,11))),
           AICc(Arima(housing_ts,order=c(4,1,12))),
           
           AICc(Arima(housing_ts,order=c(5,1,0))),
           AICc(Arima(housing_ts,order=c(5,1,1))),
           AICc(Arima(housing_ts,order=c(5,1,2))),
           AICc(Arima(housing_ts,order=c(5,1,3))),
           AICc(Arima(housing_ts,order=c(5,1,4))),
           AICc(Arima(housing_ts,order=c(5,1,5))),
           AICc(Arima(housing_ts,order=c(5,1,6))),
           AICc(Arima(housing_ts,order=c(5,1,7))),
           AICc(Arima(housing_ts,order=c(5,1,8))),
           AICc(Arima(housing_ts,order=c(5,1,9))),
           AICc(Arima(housing_ts,order=c(5,1,10))),
           AICc(Arima(housing_ts,order=c(5,1,11))),
           AICc(Arima(housing_ts,order=c(5,1,12))),
           
           AICc(Arima(housing_ts,order=c(6,1,0))),
           AICc(Arima(housing_ts,order=c(6,1,1))),
           AICc(Arima(housing_ts,order=c(6,1,2))),
           AICc(Arima(housing_ts,order=c(6,1,3))),
           AICc(Arima(housing_ts,order=c(6,1,4))),
           AICc(Arima(housing_ts,order=c(6,1,5))),
           AICc(Arima(housing_ts,order=c(6,1,6))),
           AICc(Arima(housing_ts,order=c(6,1,7))),
           AICc(Arima(housing_ts,order=c(6,1,8))),
           AICc(Arima(housing_ts,order=c(6,1,9))),
           AICc(Arima(housing_ts,order=c(6,1,10))),
           AICc(Arima(housing_ts,order=c(6,1,11))),
           AICc(Arima(housing_ts,order=c(6,1,12))),
           
           AICc(Arima(housing_ts,order=c(7,1,0))),
           AICc(Arima(housing_ts,order=c(7,1,1))),
           AICc(Arima(housing_ts,order=c(7,1,2))),
           AICc(Arima(housing_ts,order=c(7,1,3))),
           AICc(Arima(housing_ts,order=c(7,1,4))),
           AICc(Arima(housing_ts,order=c(7,1,5))),
           AICc(Arima(housing_ts,order=c(7,1,6))),
           AICc(Arima(housing_ts,order=c(7,1,7))),
           AICc(Arima(housing_ts,order=c(7,1,8))),
           AICc(Arima(housing_ts,order=c(7,1,9))),
           AICc(Arima(housing_ts,order=c(7,1,10))),
           AICc(Arima(housing_ts,order=c(7,1,11))),
           AICc(Arima(housing_ts,order=c(7,1,12))),
           
           AICc(Arima(housing_ts,order=c(8,1,0))),
           AICc(Arima(housing_ts,order=c(8,1,1))),
           AICc(Arima(housing_ts,order=c(8,1,2))),
           AICc(Arima(housing_ts,order=c(8,1,3))),
           AICc(Arima(housing_ts,order=c(8,1,4))),
           AICc(Arima(housing_ts,order=c(8,1,5))),
           AICc(Arima(housing_ts,order=c(8,1,6))),
           AICc(Arima(housing_ts,order=c(8,1,7))),
           AICc(Arima(housing_ts,order=c(8,1,8))),
           AICc(Arima(housing_ts,order=c(8,1,9))),
           AICc(Arima(housing_ts,order=c(8,1,10))),
           AICc(Arima(housing_ts,order=c(8,1,11))),
           AICc(Arima(housing_ts,order=c(8,1,12))),
           
           AICc(Arima(housing_ts,order=c(9,1,0))),
           AICc(Arima(housing_ts,order=c(9,1,1))),
           AICc(Arima(housing_ts,order=c(9,1,2))),
           AICc(Arima(housing_ts,order=c(9,1,3))),
           AICc(Arima(housing_ts,order=c(9,1,4))),
           AICc(Arima(housing_ts,order=c(9,1,5))),
           AICc(Arima(housing_ts,order=c(9,1,6))),
           AICc(Arima(housing_ts,order=c(9,1,7))),
           AICc(Arima(housing_ts,order=c(9,1,8))),
           AICc(Arima(housing_ts,order=c(9,1,9))),
           AICc(Arima(housing_ts,order=c(9,1,10))),
           AICc(Arima(housing_ts,order=c(9,1,11))),
           AICc(Arima(housing_ts,order=c(9,1,12))),
           
           AICc(Arima(housing_ts,order=c(10,1,0))),
           AICc(Arima(housing_ts,order=c(10,1,1))),
           AICc(Arima(housing_ts,order=c(10,1,2))),
           AICc(Arima(housing_ts,order=c(10,1,3))),
           AICc(Arima(housing_ts,order=c(10,1,4))),
           AICc(Arima(housing_ts,order=c(10,1,5))),
           AICc(Arima(housing_ts,order=c(10,1,6))),
           AICc(Arima(housing_ts,order=c(10,1,7))),
           AICc(Arima(housing_ts,order=c(10,1,8))),
           AICc(Arima(housing_ts,order=c(10,1,9))),
           AICc(Arima(housing_ts,order=c(10,1,10))),
           AICc(Arima(housing_ts,order=c(10,1,11))),
           AICc(Arima(housing_ts,order=c(10,1,12))),
           
           AICc(Arima(housing_ts,order=c(11,1,0))),
           AICc(Arima(housing_ts,order=c(11,1,1))),
           AICc(Arima(housing_ts,order=c(11,1,2))),
           AICc(Arima(housing_ts,order=c(11,1,3))),
           AICc(Arima(housing_ts,order=c(11,1,4))),
           AICc(Arima(housing_ts,order=c(11,1,5))),
           AICc(Arima(housing_ts,order=c(11,1,6))),
           AICc(Arima(housing_ts,order=c(11,1,7))),
           AICc(Arima(housing_ts,order=c(11,1,8))),
           AICc(Arima(housing_ts,order=c(11,1,9))),
           AICc(Arima(housing_ts,order=c(11,1,10))),
           AICc(Arima(housing_ts,order=c(11,1,11))),
           AICc(Arima(housing_ts,order=c(11,1,12))),
           
           AICc(Arima(housing_ts,order=c(12,1,0))),
           AICc(Arima(housing_ts,order=c(12,1,1))),
           AICc(Arima(housing_ts,order=c(12,1,2))),
           AICc(Arima(housing_ts,order=c(12,1,3))),
           AICc(Arima(housing_ts,order=c(12,1,4))),
           AICc(Arima(housing_ts,order=c(12,1,5))),
           AICc(Arima(housing_ts,order=c(12,1,6))),
           AICc(Arima(housing_ts,order=c(12,1,7))),
           AICc(Arima(housing_ts,order=c(12,1,8))),
           AICc(Arima(housing_ts,order=c(12,1,9))),
           AICc(Arima(housing_ts,order=c(12,1,10))),
           AICc(Arima(housing_ts,order=c(12,1,11))),
           AICc(Arima(housing_ts,order=c(12,1,12)))
)
models.2
minAICc = min(models.2)

match(minAICc, models.2)

```

  e) *Make diagnostic of the residuals for the final model chosen (autocorrelations, zero mean, normality). Use plots and tests.*
  
```{r}
#Final model 1

#Final model 3
final.model<- Arima(housing_ts,order=c(0,1,12))

summary(final.model)

print("")
print("")

final.model.mean = mean(final.model$residuals)
print(paste0("Residual Mean: ", final.model.mean))

print("")
print("")

cov2cor(final.model$var.coef)

print("")
print("")

jarque.bera.test(final.model$residuals) 


plot(final.model$residuals)

tsdiag(final.model)

```

```{r}

final.model2 = Arima(housing_ts, order = c(1,1,12))

summary(final.model2)

print("")
print("")

final.model2.mean = mean(final.model2$residuals)
print(paste0("Residual Mean: ", final.model2.mean))

print("")
print("")

cov2cor(final.model2$var.coef)

print("")
print("")

jarque.bera.test(final.model2$residuals) 


plot(final.model2$residuals)

tsdiag(final.model2)
```

  f) *Once you have found a suitable model, repeating the fitting model process several times if necessary, use it to make forecasts. Plot them.*
  
```{r}
#arima

fcst.fm=forecast(final.model, h=24)
plot(fcst.fm) #There is a problem with the data shape: it looks like residuals!

fcst.fm2=forecast(final.model2, h=24)
plot(fcst.fm2)

```
  

  g) *Use the function getrmse to compute the test set RMSE of some of the models you have already fitted. Which is the one minimizing it? Use the last year of observations (12 observations for monthly data, 4 observations for quarterly data) as the test set.*
  
```{r}
#Arminda's method
getrmse <- function(x,h,...)
{
  train.end <- time(x)[length(x)-h]   #train data end
  test.start <- time(x)[length(x)-h+1]  #test data start
  train <- window(x,end=train.end) #extract train data
  test <- window(x,start=test.start)  #extract test data
  fit <- Arima(train,...) # fit model with train data
  fc <- forecast(fit,h=h) # forecast with model
  return(accuracy(fc,test)[2,"RMSE"]) #compare forecast with test data, extract the rmse
}

#Final model 1 (best results but it is using different data!)
getrmse(housing_ts,h=12,order=c(3,1,3))
#Final model 2
getrmse(housing_ts,h=12,order=c(1,1,12))
```

  

  h) *You can also use the auto.arima() function with some of its parameters fixed, to see if it suggests a better model that the one you have found. Don’t trust blindly its output. Automatic found models aren’t based on an analysis of residuals but in comparing some other measures like AIC. Depending on how complex the data set is, they may find models with high values for p, q, P or Q (greater than 2).*
  
```{r}
auto.model <- auto.arima(d.ts,
                         seasonal= FALSE,
                         max.order = 24,
                         max.p = 14,
                         max.q = 14
                         )

summary(auto.model)

print("")
print("")

auto.model.mean = mean(auto.model$residuals)
print(paste0("Residual Mean: ", auto.model.mean))

print("")
print("")

cov2cor(auto.model$var.coef)

print("")
print("")

jarque.bera.test(auto.model$residuals) 


plot(auto.model$residuals)

tsdiag(auto.model)

```


```{r}

tsdisplay(residuals(auto.model), lag.max=15, main='Automatic Model Residuals')
tsdisplay(residuals(final.model), lag.max=15, main='Final Model 1 Residuals')
tsdisplay(residuals(final.model2), lag.max=15, main='Final Model 2 Residuals')

```


  
  