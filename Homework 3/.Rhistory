arima.train=window(housing_ts, end=2007-0.001)
arima.test=window(housing_ts,start=2007)
final.model2.predict = arima(arima.train, order = c(12,1,12))
autoplot(predict(final.model2.predict, 12))
#To be honest i cant find that function. We may have to load it.
#Training and testing data split
arima.train=window(housing_ts, end=2007-0.001)
arima.test=window(housing_ts,start=2007)
final.model2.predict = arima(arima.train, order = c(12,1,12))
arims.predict = predict(final.model2.predict, 12)
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
# sqrt(mean((arima.fcst$mean - arima.test)^2, na.rm=TRUE))
arims.predict
arima.test
#To be honest i cant find that function. We may have to load it.
arima.predict = predict(final.model2, 12)
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
# sqrt(mean((arima.fcst$mean - arima.test)^2, na.rm=TRUE))
#To be honest i cant find that function. We may have to load it.
arima.predict = predict(final.model2, 12)
arima.predict
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
# sqrt(mean((arima.fcst$mean - arima.test)^2, na.rm=TRUE))
#To be honest i cant find that function. We may have to load it.
arima.predict = predict(final.model2, 12)
arima.predict
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
sqrt(mean((arima.predict$pred - arima.predict$se)^2, na.rm=TRUE))
#Training and testing data split
housing.train=window(housing_ts, end=2004-0.001) #~0.8
housing.test=window(housing_ts,start=2004) #~0.2
#The slope at the transition between testing and training datasets influences how easy is to predict the future values. The year at which we divide the time series determines which method has the lowest RMSE.
#forecasting with stl(): different methods: naive, ets, arima, rwdrift
stl.housing <- stl(housing.train, t.window=5, s.window="periodic", robust=TRUE)
#naive
fcst=forecast(stl.housing, method="naive", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean - housing.test)^2, na.rm=TRUE))
#ets
fcst=forecast(stl.housing, method="ets", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean-housing.test)^2, na.rm=TRUE))
#arima
fcst=forecast(stl.housing, method="arima", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean-housing.test)^2, na.rm=TRUE))
#rwdrift
fcst=forecast(stl.housing, method="rwdrift", h=24)
plot(fcst)
#fcst$mean
# Validation: test error  RMSE
sqrt(mean((fcst$mean-housing.test)^2, na.rm=TRUE)) #Lowest RMSE
fcst$mean
fcst
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
sqrt(mean((arima.predict$se - arima.predict$pred)^2, na.rm=TRUE))
arima.predict$pred - arima.predict$se
#To be honest i cant find that function. We may have to load it.
arima.predict = predict(final.model2, 12)
arima.predict
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
sqrt(mean((arima.predict$pred - arima.predict$se)^2, na.rm=TRUE))
housing_ts
housing_ts
arima.predict
#To be honest i cant find that function. We may have to load it.
#Training and testing data split
arima.train=window(housing_ts, end=2007-0.001)
arima.test=window(housing_ts,start=2007)
final.model2.predict = arima(arima.train, order = c(12,1,12))
arima.predict = predict(final.model2.predict, 12)
arima.predict
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
# sqrt(mean((arima.fcst$mean - arima.test)^2, na.rm=TRUE))
arima.train
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
sqrt(mean((arima.predict$pred - arima.test)^2, na.rm=TRUE))
#To be honest i cant find that function. We may have to load it.
#Training and testing data split
arima.train=window(housing_ts, end=2007-0.001)
arima.test=window(housing_ts,start=2007)
final.model2.predict = arima(arima.train, order = c(12,1,12))
arima.predict = predict(final.model2.predict, 12)
arima.predict
#
# arima.fcst=forecast(final.model2, h=24, )
# plot(arima.fcst)
#
# # Validation: test error  RMSE
sqrt(mean((arima.predict$pred - arima.test)^2, na.rm=TRUE))
typeof(arima.predict)
?predict
# current_ts = d.ts
# #We start testing with the D = 0 (or to the previous defined values) and we change in the models the values of p and q
#   # q = 0
# models = c(
# c(AICc(arima(current_ts, order = c(1,0,0)))
# ,AICc(arima(current_ts, order = c(2,0,0)))
# ,AICc(arima(current_ts, order = c(3,0,0)))
# ,AICc(arima(current_ts, order = c(4,0,0))))
# ,
# c(  # q = 1
# AICc(arima(current_ts, order = c(1,0,1)))
# ,AICc(arima(current_ts, order = c(2,0,1)))
# ,AICc(arima(current_ts, order = c(3,0,1)))
# ,AICc(arima(current_ts, order = c(4,0,1))))
# ,
# c(  # q = 2
# AICc(arima(current_ts, order = c(1,0,2)))
# ,AICc(arima(current_ts, order = c(2,0,2)))
# ,AICc(arima(current_ts, order = c(3,0,2)))
# ,AICc(arima(current_ts, order = c(4,0,2))))
# ,
# c(  # q = 3
# AICc(arima(current_ts, order = c(1,0,3)))
# ,AICc(arima(current_ts, order = c(2,0,3)))
# ,AICc(arima(current_ts, order = c(3,0,3)))
# ,AICc(arima(current_ts, order = c(4,0,3))))
# ,
# c(  # q = 4
# AICc(arima(current_ts, order = c(1,0,4)))
# ,AICc(arima(current_ts, order = c(2,0,4)))
# ,AICc(arima(current_ts, order = c(3,0,4)))
# ,AICc(arima(current_ts, order = c(4,0,4))))
# )
#We start testing with the D = 0 (or to the previous defined values) and we change in the models the values of p and q
# q = 0
models = c(
c(AICc(arima(housing_ts, order = c(1,1,0)))
,AICc(arima(housing_ts, order = c(2,1,0)))
,AICc(arima(housing_ts, order = c(3,1,0)))
,AICc(arima(housing_ts, order = c(4,1,0))))
,
c(  # q = 1
AICc(arima(housing_ts, order = c(1,1,1)))
,AICc(arima(housing_ts, order = c(2,1,1)))
,AICc(arima(housing_ts, order = c(3,1,1)))
,AICc(arima(housing_ts, order = c(4,1,1))))
,
c(  # q = 2
AICc(arima(housing_ts, order = c(1,1,2)))
,AICc(arima(housing_ts, order = c(2,1,2)))
,AICc(arima(housing_ts, order = c(3,1,2)))
,AICc(arima(housing_ts, order = c(4,1,2))))
,
c(  # q = 3
AICc(arima(housing_ts, order = c(1,1,3)))
,AICc(arima(housing_ts, order = c(2,1,3)))
,AICc(arima(housing_ts, order = c(3,1,3)))
,AICc(arima(housing_ts, order = c(4,1,3))))
,
c(  # q = 4
AICc(arima(housing_ts, order = c(1,1,4)))
,AICc(arima(housing_ts, order = c(2,1,4)))
,AICc(arima(housing_ts, order = c(3,1,4)))
,AICc(arima(housing_ts, order = c(4,1,4), optim.control =  list(maxit = 1000))))
)
models
# #Lowest value appears to be p=3 d=0 q=3 with a value of: (373.2994)
min(models)
#To be honest i cant find that function. We may have to load it.
#Training and testing data split
arima.train=window(housing_ts, end=2007-0.001)
arima.test=window(housing_ts,start=2007)
final.model2.predict = arima(arima.train, order = c(12,1,12))
arima.predict = predict(final.model2.predict, 12)
arima.predict
arima.test
# # Validation: test error  RMSE
sqrt(mean((arima.predict$pred - arima.test)^2, na.rm=TRUE))
#arima
fcst.fm=forecast(final.model, h=24)
plot(fcst.fm)
fcst.fm2=forecast(final.model2, h=24)
plot(fcst.fm2)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
summary(final.model)
acf(current_ts)
pacf(current_ts)
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(12,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(0,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(12,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(0,1,12))
summary(final.model2)
final.model3 = arima(housing_ts, order = c(12,1,12))
summary(final.model3)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(0,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(1,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(2,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(5,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(0,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(0,1,12))
summary(final.model2)
acf(final.model2$residuals)
pacf(final.model2$residuals)
jarque.bera.test(final.model2$residuals)
plot(final.model2$residuals)
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = arima(housing_ts, order = c(0,1,12))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(housing_ts, order = c(0,1,12))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
#We visualize the spike in the residuals
tsdisplay(residuals(arima(current_ts, order = c(3,0,3))), lag.max=15, main='Model Reiduals')
curr_test <- arima(current_ts, order = c(0,0,12))
AICc(arima(current_ts, order = c(0,0,12)))  #We get a much lower value
tsdisplay(residuals(curr_test), lag.max=15, main='0 0 12 Model Reiduals')
curr_test2 <- arima(current_ts, order = c(12,0,0))
AICc(arima(current_ts, order = c(12,0,0)))  #We get a lower value
tsdisplay(residuals(curr_test2), lag.max=15, main='12 0 0 Model Reiduals')
curr_test3 <- arima(current_ts, order = c(12,0,12))
AICc(arima(current_ts, order = c(12,0,12)))  #We get a lower value
tsdisplay(residuals(curr_test3), lag.max=15, main='12 0 12 Model Reiduals')
curr_test4 <- Arima(housing_ts, order = c(12,1,12))
AICc(curr_test4)  #We get a lower value
tsdisplay(residuals(curr_test4), lag.max=15, main='12 1 12 Model Reiduals')
#We visualize the spike in the residuals
tsdisplay(residuals(arima(current_ts, order = c(3,0,3))), lag.max=15, main='Model Reiduals')
curr_test <- arima(current_ts, order = c(0,0,12))
AICc(arima(current_ts, order = c(0,0,12)))  #We get a much lower value
tsdisplay(residuals(curr_test), lag.max=15, main='0 0 12 Model Reiduals')
curr_test2 <- arima(current_ts, order = c(12,0,0))
AICc(arima(current_ts, order = c(12,0,0)))  #We get a lower value
tsdisplay(residuals(curr_test2), lag.max=15, main='12 0 0 Model Reiduals')
curr_test3 <- arima(current_ts, order = c(12,0,12))
AICc(arima(current_ts, order = c(12,0,12)))  #We get a lower value
tsdisplay(residuals(curr_test3), lag.max=15, main='12 0 12 Model Reiduals')
curr_test4 <- arima(housing_ts, order = c(12,1,12))
AICc(curr_test4)  #We get a lower value
tsdisplay(residuals(curr_test4), lag.max=15, main='12 1 12 Model Reiduals')
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(housing_ts, order = c(0,1,0))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(housing_ts, order = c(0,1,12), s seasonal = c(2,0,2))
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(housing_ts, order = c(0,1,12), seasonal = c(2,0,2))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(housing_ts, order = c(0,1,12))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(log(housing_ts), order = c(0,1,12))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(diff(housing_ts), order = c(0,1,12))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(housing_ts, order = c(0,1,12))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
jarque.bera.test(final.model2$residuals)
source('~/.active-rstudio-document', echo=TRUE)
auto.model <- auto.arima(d.ts,
seasonal= TRUE,
max.order = 24,
max.p = 14,
max.q = 14)
summary(auto.model)
tsdisplay(residuals(auto.model), lag.max=15, main='Automatic Model Reiduals')
tsdisplay(residuals(final.model), lag.max=15, main='Final Model Reiduals')
tsdisplay(residuals(final.model2), lag.max=15, main='Final Model Reiduals')
jarque.bera.test(final.model2$residuals)
auto.model <- auto.arima(d.ts,
seasonal= TRUE,
max.order = 24,
max.p = 14,
max.q = 14)
summary(auto.model)
tsdisplay(residuals(auto.model), lag.max=15, main='Automatic Model Reiduals')
tsdisplay(residuals(final.model), lag.max=15, main='Final Model Reiduals')
tsdisplay(residuals(final.model2), lag.max=15, main='Final Model Reiduals')
jarque.bera.test(final.model2$residuals)
#To make diagnostics, we should analyse the ACF and PACF values
final.model = arima(current_ts, order = c(0,0,12))
# summary(final.model)
#
# acf(current_ts)
# pacf(current_ts)
#
#To make diagnostics, we should analyse the ACF and PACF values
final.model2 = Arima(housing_ts, order = c(0,1,12))
summary(final.model2)
plot(final.model2$residuals)
tsdiag(final.model2)
tsdisplay(residuals(final.model2), lag.max=15, main='Final Model Reiduals')
jarque.bera.test(final.model2$residuals)
