---
title: "R Notebook"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

```{r}
diamonds <- read.delim("HW-diamonds.txt", header = FALSE, sep = "", dec = ".")
```

```{r}
head(diamonds)
```


```{r}
colnames(diamonds) <- c("caratage", "purity", "clarity", "certificate", "price")
diamonds$purity <- factor(diamonds$purity, levels=c("D", "E", "F", "G", "H", "I"))
diamonds$clarity <- factor(diamonds$clarity, levels=c("VS2", "VS1", "VVS2", "VVS1", "IF"))
```

```{r}
summary(diamonds)
```

```{r}
library(dplyr)
library(ggplot2)
library(tseries)
library(lmtest)
library(car)
```

### 1. Plot price vs caratage and log(price) vs caratage. Decide on which response variable is better to use

```{r}
ggplot(data=diamonds, aes(price, caratage)) + 
        geom_point()
ggplot(data=diamonds, aes(log(price), caratage)) + 
        geom_point()
```

log(price) seems more linear (maybe different transformations?)

### 2. Find a suitable way to include, besides caratage, the other categorical information
available: clarity, color and certificate. Use the worst level of each categorical variable
as the reference category and HRD for certification institution. Comment on the model
fitted, and perform a basic analysis of the residuals (normality, constant variance,
independence, you may also want to use the function outlierTest or residualPlot ).
```{r}
#Starting model
model.1.1<-lm(formula = price ~ caratage + purity + clarity + certificate, data = diamonds)
summary(model.1.1)
```
```{r}
#Let's try to predict log(price)
model.1.2<-lm(formula = log(price) ~ caratage + purity + clarity + certificate, data = diamonds)
summary(model.1.2)
#model1.2 has a lower residual standard error and a higher R^2. We will predict log(price).
```
```{r}
#By default, the category that R chooses to be the reference or baseline, is the first category that appears alphabetically or  numerically (if categories are coded using 0,1,2,...).
#Let's use the worst level of each categorical variable as the reference category and HRD for certification institution.
diamonds$purity <- relevel(diamonds$purity, ref = "I")
diamonds$clarity <- relevel(diamonds$clarity, ref = "VS2")
diamonds$certificate <- relevel(diamonds$certificate, ref = "HRD")
model.1.3<-lm(formula = log(price) ~ caratage + purity + clarity + certificate, data = diamonds)
summary(model.1.3)
#Same statistics as model1.2.
```
```{r}
#Let's check the interactions.
model.1.4 <- lm(formula = log(price) ~ .^2, data = diamonds)
summary(model.1.4)
#The standard error decreases  and th R^2 increases. However, only some interactions are relevant. Let's keep only those.
```
```{r}
model.1.5 <- lm(formula = log(price) ~ caratage + purity + clarity + certificate + caratage:purity + caratage:clarity + caratage:certificate, data = diamonds)
summary(model.1.5)
#model.1.5 shows slightly worse statistics than model.1.4 but is way simpler.
```

```{r}
model.1.5 <- lm(formula = log(price) ~ caratage + purity + clarity + certificate + caratage:certificate, data = diamonds)
summary(model.1.5)
#model.1.5 shows slightly worse statistics than model.1.4 but is way simpler.
```

```{r}
#Let's analyse this model deeper.
# Residuals vs Fitted Plot
residuals_vs_fitted_model.1.5<-plot(model.1.5, which=1, col=c("blue"))
#Normal Q-Q Plot
qq_plot_model.1.5<-plot(model.1.5, which=2, col=c("blue")) 
#Scale-Location
residuals_vs_fitted_model.1.5<-plot(model.1.5, which=3, col=c("blue"))
#Residuals vs Leverage
residuals_vs_fitted_model.1.5<-plot(model.1.5, which=5, col=c("blue")) 
#We use Jarque-Bera to test the residuals
jarque.bera.test(model.1.5$residuals) 
#To test the independance, we do the Durbin-Watson test
dwtest(model.1.5) 
#For constant variance we'd use Breusch-Pagan
bptest(model.1.5)
# We'll use outlierTest and residualPlot
outlierTest(model.1.5)
residualPlot(model.1.5)
```

```{r}
#Are we getting better results than with the previous models? Let's repeat the residual analysis for all and compare the results!
library(ggpubr)
residuals_vs_fitted_model.1.1<-plot(model.1.1, which=1, col=c("red"))
qq_plot_model.1.1<-plot(model.1.1, which=2, col=c("red")) 
residuals_vs_fitted_model.1.1<-plot(model.1.1, which=3, col=c("red"))
residuals_vs_fitted_model.1.1<-plot(model.1.1, which=5, col=c("red"))

residuals_vs_fitted_model.1.2<-plot(model.1.2, which=1, col=c("forestgreen"))
qq_plot_model.1.2<-plot(model.1.2, which=2, col=c("forestgreen")) 
residuals_vs_fitted_model.1.2<-plot(model.1.2, which=3, col=c("forestgreen"))
residuals_vs_fitted_model.1.2<-plot(model.1.2, which=5, col=c("forestgreen"))

residuals_vs_fitted_model.1.3<-plot(model.1.3, which=1, col=c("darkorchid"))
qq_plot_model.1.3<-plot(model.1.3, which=2, col=c("darkorchid")) 
residuals_vs_fitted_model.1.3<-plot(model.1.3, which=3, col=c("darkorchid"))
residuals_vs_fitted_model.1.3<-plot(model.1.3, which=5, col=c("darkorchid"))

residuals_vs_fitted_model.1.4<-plot(model.1.4, which=1, col=c("brown"))
qq_plot_model.1.4<-plot(model.1.4, which=2, col=c("brown")) 
residuals_vs_fitted_model.1.4<-plot(model.1.4, which=3, col=c("brown"))
residuals_vs_fitted_model.1.4<-plot(model.1.4, which=5, col=c("brown"))

residuals_vs_fitted_all <- ggarrange(
  residuals_vs_fitted_model.1.1,residuals_vs_fitted_model.1.2,residuals_vs_fitted_model.1.3,
  residuals_vs_fitted_model.1.4,residuals_vs_fitted_model.1.5,nrow = 2,ncol = 3)
residuals_vs_fitted_all

qq_plot_all <- ggarrange(
  qq_plot_model.1.1,qq_plot_model.1.2,qq_plot_model.1.3,
  qq_plot_model.1.4,qq_plot_model.1.5,nrow = 2,ncol = 3)
qq_plot_all

```



### 3. Try two different remedial actions:

### 3a. Create a new categorical variable to segregate the stones according to caratage: let's say less than 0.5 carats small, 0.5 to less than 1 carat (medium) and 1 carat and over (large). Make small as the reference category. Add this new variable to the existing model as well as an interaction term between this new variable and caratage.

```{r}
diamonds_new <- mutate(
  diamonds,
  caratage_category = as.factor(
    case_when(
      caratage < 0.5 ~ 's',
      caratage < 1 ~ 'm',
      caratage >= 1 ~ 'l'
      )
    )
  )

diamonds_new$caratage_category <- relevel(diamonds_new$caratage_category, ref = "s")

```


* Is this regression model satisfactory? Are the standard assumptions of linear
regression validated? Are the numerical estimates sensible?

The model seems to be better than before, having a Radj value of 0.996

* Interpret the interaction parameter med*carat. What can we infer on the incremental pricing of caratage in the 3 clusters?

An increment of one unit in any of the categorties would result in an increment depending on the category  (being category S 1, M 0.84 and L 2.18)

* Which is more highly valued: colour or clarity?


* All other things being equal, what is the average price difference between a grade D diamond and another one graded (a) I (b) E?

DI: it's 0.294240, being D higher than I
DE: it's 0.046429, being E higher than D

* All other things being equal, are there price differences amongst the stones appraised by the GIA, IGI and HRD?

There is some difference but it's really small and also the p-values are higher than 0.05.

```{r}
#We add Caratage category to the latest model
model.1.5.1 <- lm(formula = log(price) ~ caratage*caratage_category + purity + clarity + certificate + caratage:purity + caratage:clarity + caratage:certificate , data = diamonds_new)
summary(model.1.5.1)

#Let's analyse this model deeper.
# Residuals vs Fitted Plot
residuals_vs_fitted_model.1.5.1<-plot(model.1.5.1, which=1, col=c("blue"))
#Normal Q-Q Plot
qq_plot_model.1.5.1<-plot(model.1.5.1, which=2, col=c("blue")) 
#Scale-Location
residuals_vs_fitted_model.1.5.1<-plot(model.1.5.1, which=3, col=c("blue"))
#Residuals vs Leverage
residuals_vs_fitted_model.1.5.1<-plot(model.1.5.1, which=5, col=c("blue")) 
#We use Jarque-Bera to test the residuals
jarque.bera.test(model.1.5.1$residuals) 
#To test the independance, we do the Durbin-Watson test
dwtest(model.1.5.1) 
#For constant variance we'd use Breusch-Pagan
bptest(model.1.5.1)
# We'll use outlierTest and residualPlot
outlierTest(model.1.5.1)
residualPlot(model.1.5.1)

# To test if clarity or purity is better than the other
anova(model.1.5.1)
```

```{r}
#We add Caratage category to the latest model
model.1.5.1 <- lm(formula = log(price) ~ caratage*caratage_category + purity + clarity + certificate + caratage:certificate , data = diamonds_new)
summary(model.1.5.1)

#Let's analyse this model deeper.
# Residuals vs Fitted Plot
residuals_vs_fitted_model.1.5.1<-plot(model.1.5.1, which=1, col=c("blue"))
#Normal Q-Q Plot
qq_plot_model.1.5.1<-plot(model.1.5.1, which=2, col=c("blue")) 
#Scale-Location
residuals_vs_fitted_model.1.5.1<-plot(model.1.5.1, which=3, col=c("blue"))
#Residuals vs Leverage
residuals_vs_fitted_model.1.5.1<-plot(model.1.5.1, which=5, col=c("blue")) 
#We use Jarque-Bera to test the residuals
jarque.bera.test(model.1.5.1$residuals) 
#To test the independance, we do the Durbin-Watson test
dwtest(model.1.5.1) 
#For constant variance we'd use Breusch-Pagan
bptest(model.1.5.1)
# We'll use outlierTest and residualPlot
outlierTest(model.1.5.1)
residualPlot(model.1.5.1)

# To test if clarity or purity is better than the other


```

### 3b. Include the square of carat as a new explanatory variable. It avoids the subjectivity of clusters definition.

```{r}

diamonds_c2 <- mutate(
  diamonds,
  caratage2 = caratage^2
  )
model.1.5.2 <- lm(formula = log(price) ~ caratage + caratage2 + purity + clarity + certificate + caratage:purity + caratage:clarity + caratage:certificate , data = diamonds_c2)
summary(model.1.5.2)

```


### 4. Which of the two remedial actions do you prefer and why? Think on terms of interpretability and validity of the assumptions of the avoiding the subjectivity of cluster definition.

In the first one we are using more variables and are mure subjective (we get the small, medium and large values from the text but we don't se much logic between the numbers/ranges) but for the second one using the caratage squered seems a bit farfetched to understand why  

```{r}
```


